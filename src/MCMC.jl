#################################################################
#
#    Main file of MCMC.jl module
#
#################################################################

module MCMC

using DataFrames
using Distributions # logcdf() and Normal() are used in src/bayesglmmodels.jl (log-likelihood of Bayesian probit model)

import Base.*, Base.show
export show, *
export MCMCTask, MCMCChain

###########  Models and autodiff  ##########
include("modellers/mcmcmodels.jl")      #  include model types definitions		

###########  Models and autodiff  ##########
include("autodiff/parsing.jl")     #  include model expression parsing function
include("autodiff/diff.jl")        #  include derivatives definitions
include("autodiff/distributions.jl")    #  include distributions definitions

### MCMCTask type, generated by combining a MCMCModel with a MCMCSampler
type MCMCTask
  task::Task
  model::MCMCModel
end
reset(t::MCMCTask, x) = t.task.storage[:reset](x)

#############  samplers  ########################
include("samplers/samplers.jl")  # Common definitions for samplers

include("samplers/RWM.jl")    # Random-walk Metropolis sampler
include("samplers/MALA.jl")   # Metropolis adjusted Langevin algorithm sampler
include("samplers/HMC.jl")    # Hamiltonian Monte-Carlo sampler
include("samplers/NUTS.jl")   # No U-Turn Hamiltonian Monte-Carlo sampler
include("samplers/SMMALA.jl") # Simplified manifold Metropolis adjusted Langevin algorithm sampler
include("samplers/MMALA.jl")  # Manifold Metropolis adjusted Langevin algorithm sampler
include("samplers/RMHMC.jl")  # Riemannian manifold Hamiltonian Monte Carlo sampler

#  Definition of * as a shortcut operator for model and sampler combination 
*{M<:MCMCModel, S<:MCMCSampler}(m::M, s::S) = spinTask(m, s)
*{M<:MCMCModel, S<:MCMCSampler}(m::Array{M}, s::S) = map((me) -> spinTask(me, s), m)
*{M<:MCMCModel, S<:MCMCSampler}(m::M, s::Array{S}) = map((se) -> spinTask(m, se), s)

### MCMCChain, the result of running a MCMCTask
type MCMCChain
  range::Range{Int}
  samples::DataFrame
  gradients::DataFrame
  diagnostics::DataFrame
  task::Union(MCMCTask, Array{MCMCTask})
  runTime::Float64
   
  function MCMCChain(	r::Range{Int}, s::DataFrame, g::DataFrame, d::DataFrame, 
  						t::Union(MCMCTask, Array{MCMCTask}), rt::Float64)
    if !isempty(g); assert(size(s) == size(g), "samples and gradients must have the same number of rows and columns"); end
    if !isempty(d); assert(nrow(s) == nrow(d), "samples and diagnostics must have the same number of rows"); end
    new(r, s, g, d, t, rt)
  end
end

MCMCChain(r::Range{Int}, s::DataFrame, d::DataFrame, t::Union(MCMCTask, Array{MCMCTask}), rt::Float64) = 
	MCMCChain(r, s, DataFrame(), d, t, rt)
MCMCChain(r::Range{Int}, s::DataFrame, t::Union(MCMCTask, Array{MCMCTask}), rt::Float64) = 
	MCMCChain(r, s, DataFrame(), DataFrame(), t, rt)
MCMCChain(r::Range{Int}, s::DataFrame, d::DataFrame, t::Union(MCMCTask, Array{MCMCTask})) = 
	MCMCChain(r, s, DataFrame(), d, t, NaN)
MCMCChain(r::Range{Int}, s::DataFrame, t::Union(MCMCTask, Array{MCMCTask})) = 
	MCMCChain(r, s, DataFrame(), DataFrame(), t, NaN)

function show(io::IO, res::MCMCChain)
  println("$(ncol(res.samples)) parameters, $(nrow(res.samples)) samples (per parameter), $(round(res.runTime, 1)) sec.")
end

#############  runners    ########################

include("runners/run.jl")         # Vanilla runner
include("runners/seqMC.jl")       # Sequential Monte-Carlo runner
include("runners/serialMC.jl")    # Serial Tempering Monte-Carlo runner

#############  MCMC output analysis and diagnostics    ########################
include("stats/acf.jl") # Autocorrelation functions (temporarily placed here)
include("stats/var.jl") # MCMC variance estimators
include("stats/ess.jl") # Effective sample size and integrated autocorrelation time functions
include("stats/zv.jl")  # ZV-MCMC estimators
end
